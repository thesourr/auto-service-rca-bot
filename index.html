<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Service-uri Auto Rom√¢nia - Dashboard</title>
    <meta name="description" content="ListƒÉ actualizatƒÉ cu service-uri auto din Rom√¢nia - Bucure»ôti, Cluj, Timi»ôoara »ôi alte ora»ôe">
    <meta name="robots" content="noindex">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        header p {
            opacity: 0.9;
            font-size: 1rem;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 30px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #2563eb;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #64748b;
            font-size: 0.875rem;
        }

        .filters {
            padding: 30px;
            background: white;
            border-bottom: 1px solid #e2e8f0;
        }

        .filter-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #475569;
        }

        select, input[type="text"] {
            padding: 10px 15px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            font-size: 0.875rem;
            transition: all 0.2s;
            min-width: 200px;
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .checkbox-group {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: normal;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .button {
            padding: 10px 20px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .button:hover {
            background: #1d4ed8;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .button-secondary {
            background: #64748b;
        }

        .button-secondary:hover {
            background: #475569;
        }

        .table-container {
            padding: 30px;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        th {
            background: #f1f5f9;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #334155;
            cursor: pointer;
            user-select: none;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th:hover {
            background: #e2e8f0;
        }

        th.sortable::after {
            content: ' ‚áÖ';
            opacity: 0.3;
        }

        th.sort-asc::after {
            content: ' ‚Üë';
            opacity: 1;
        }

        th.sort-desc::after {
            content: ' ‚Üì';
            opacity: 1;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #f1f5f9;
        }

        tr:hover {
            background: #f8fafc;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .badge-small {
            background: #e2e8f0;
            color: #475569;
        }

        .badge-medium {
            background: #fef3c7;
            color: #92400e;
        }

        .badge-large {
            background: #d1fae5;
            color: #065f46;
        }

        .badge-unknown {
            background: #f1f5f9;
            color: #94a3b8;
        }

        .badge-sent {
            background: #dcfce7;
            color: #166534;
        }

        .rating {
            color: #fbbf24;
        }

        a {
            color: #2563eb;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .icon-link {
            margin-left: 5px;
            font-size: 0.75rem;
        }

        .email-cell {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .copy-btn {
            cursor: pointer;
            padding: 2px 6px;
            background: #f1f5f9;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .copy-btn:hover {
            background: #e2e8f0;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 20px;
            border-top: 1px solid #e2e8f0;
        }

        .pagination button {
            padding: 8px 12px;
            background: white;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pagination button:hover:not(:disabled) {
            background: #f1f5f9;
            border-color: #2563eb;
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination .page-info {
            color: #64748b;
            font-size: 0.875rem;
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: #64748b;
            font-size: 1.125rem;
        }

        .error {
            text-align: center;
            padding: 60px;
            color: #dc2626;
        }

        .sent-history-summary {
            font-size: 0.875rem;
            color: #334155;
            margin-top: 10px;
        }

        .sent-preview-list {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #475569;
            max-height: 120px;
            overflow-y: auto;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 8px;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.5rem;
            }

            .stats {
                grid-template-columns: 1fr;
            }

            .filter-row {
                flex-direction: column;
                align-items: stretch;
            }

            .checkbox-group {
                flex-direction: column;
                align-items: flex-start;
            }

            table {
                font-size: 0.75rem;
            }

            th, td {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üöó Service-uri Auto Rom√¢nia</h1>
            <p>Dashboard cu service-uri auto actualizat automat</p>
        </header>

        <div class="stats" id="stats">
            <div class="stat-card">
                <div class="stat-value" id="totalCount">-</div>
                <div class="stat-label">Total Service-uri</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="emailCount">-</div>
                <div class="stat-label">Cu Email</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="largeCount">-</div>
                <div class="stat-label">Service-uri Mari</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="lastUpdated">-</div>
                <div class="stat-label">Ultima Actualizare (Data/Ora)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="sentCount">-</div>
                <div class="stat-label">Contactate Deja</div>
            </div>
        </div>

        <div class="filters">
            <div class="filter-row">
                <div class="filter-group">
                    <label for="cityFilter">Ora»ô</label>
                    <select id="cityFilter">
                        <option value="">Toate Ora»ôele</option>
                    </select>
                </div>

                <div class="filter-group">
                    <label for="searchInput">CautƒÉ √Æn nume</label>
                    <input type="text" id="searchInput" placeholder="Ex: Mercedes, BMW...">
                </div>

                <div class="filter-group">
                    <label>Dimensiune</label>
                    <div class="checkbox-group">
                        <label><input type="checkbox" value="small" checked> Mici</label>
                        <label><input type="checkbox" value="medium" checked> Medii</label>
                        <label><input type="checkbox" value="large" checked> Mari</label>
                    </div>
                </div>
            </div>

            <div class="filter-row">
                <label>
                    <input type="checkbox" id="emailOnlyFilter">
                    Doar cu email
                </label>
                <label>
                    <input type="checkbox" id="hideSentFilter">
                    Ascunde deja contactate
                </label>

                <button class="button button-secondary" onclick="clearFilters()">ReseteazƒÉ Filtre</button>
                <button class="button" id="runScrapeBtn" onclick="runScrapeWorkflow()" style="background: #7c3aed;">üõ∞Ô∏è CautƒÉ Service-uri Noi</button>
                <button class="button" onclick="rerunServiceSearch()" style="background: #0ea5e9;">üîé ActualizeazƒÉ CƒÉutarea</button>
                <button class="button" onclick="refreshAllData()" style="background: #16a34a;">üîÑ Refresh Date</button>
                <button class="button" onclick="exportFilteredCSV()">üì• Export CSV</button>
            </div>
            <div id="scrapeStatus" style="font-size: 0.875rem; color: #64748b; margin-top: 8px;">
                CƒÉutare service-uri: inactivƒÉ.
            </div>
        </div>

        <!-- Email Actions -->
        <div class="filters" id="emailActions" style="display: none; background: #f0f9ff; border: 2px solid #3b82f6;">
            <div class="filter-row">
                <strong style="color: #1e40af;">üìß Ac»õiuni Email:</strong>
                <span id="selectedCount" style="color: #64748b;">0 selectate</span>
                <button class="button" onclick="sendTestEmail()" style="background: #10b981;">
                    üß™ Trimite Email de Test
                </button>
                <button class="button" onclick="sendEmailsDirectLocal()" style="background: #f59e0b;" id="sendDirectBtn" disabled>
                    ‚úâÔ∏è Trimite Direct (Local)
                </button>
                <button class="button" onclick="sendEmailsToSelected()" style="background: #3b82f6;" id="sendEmailBtn" disabled>
                    üì• Download Email List
                </button>
                <button class="button button-secondary" onclick="clearSelection()">
                    ‚úñ DeselecteazƒÉ Tot
                </button>
            </div>
            <div style="font-size: 0.875rem; color: #64748b; margin-top: 10px;">
                üí° <strong>Tip:</strong> Pentru trimitere directƒÉ, porne»ôte local bridge-ul cu: <code>python3 local_mail_bridge.py</code>. Lista exclude automat service-urile marcate ca deja contactate.
            </div>
            <div id="localSendStatus" style="font-size: 0.875rem; color: #64748b; margin-top: 8px;">
                Trimitere localƒÉ: inactivƒÉ.
            </div>
        </div>

        <div class="filters" id="sentHistoryPanel" style="background: #f8fafc; border: 1px solid #cbd5e1;">
            <div class="filter-row">
                <strong style="color: #0f172a;">üì¨ Istoric Email-uri Trimise</strong>
                <button class="button" onclick="triggerHistoryImport()" style="background: #0ea5e9;">
                    üì§ ImportƒÉ Istoric JSON
                </button>
                <button class="button button-secondary" onclick="manualSyncSentHistory()">
                    ‚òÅÔ∏è Sync din Repo
                </button>
                <button class="button button-secondary" onclick="exportSentHistory()">
                    üì• ExportƒÉ Istoric
                </button>
                <button class="button button-secondary" onclick="clearSentHistory()">
                    üóëÔ∏è »òterge Istoric
                </button>
                <input type="file" id="historyFileInput" accept=".json,application/json" style="display:none;" onchange="handleHistoryFile(event)">
            </div>
            <div class="sent-history-summary" id="sentHistorySummary">
                Nu existƒÉ istoric √ÆncƒÉrcat.
            </div>
            <div class="sent-preview-list" id="sentPreviewList" style="display: none;"></div>
        </div>

        <div class="table-container">
            <div id="loading" class="loading">√éncƒÉrcare date...</div>
            <div id="error" class="error" style="display: none;"></div>
            <table id="servicesTable" style="display: none;">
                <thead>
                    <tr>
                        <th>
                            <input type="checkbox" id="selectAll" onchange="toggleSelectAll()" title="SelecteazƒÉ tot">
                        </th>
                        <th class="sortable" data-sort="name">Nume</th>
                        <th class="sortable" data-sort="city">Ora»ô</th>
                        <th class="sortable" data-sort="size">Dimensiune</th>
                        <th class="sortable" data-sort="rating">Rating</th>
                        <th class="sortable" data-sort="reviews">Review-uri</th>
                        <th>Email</th>
                        <th>Telefon</th>
                        <th>Website</th>
                    </tr>
                </thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>

        <div class="pagination" id="pagination" style="display: none;">
            <button onclick="prevPage()">‚Üê Anterior</button>
            <span class="page-info" id="pageInfo"></span>
            <button onclick="nextPage()">UrmƒÉtor ‚Üí</button>
        </div>
    </div>

    <script>
        // Configurare
        const ITEMS_PER_PAGE = 50;
        const SENT_HISTORY_STORAGE_KEY = 'sent_email_history_v1';
        const GITHUB_OWNER = 'thesourr';
        const GITHUB_REPO = 'auto-service-rca-bot';
        const GITHUB_BRANCH = 'main';
        const SCRAPE_WORKFLOW_FILE = 'scrape.yml';
        const LOCAL_MAIL_BRIDGE_URL = 'http://127.0.0.1:8765';
        let allServices = [];
        let filteredServices = [];
        let currentPage = 1;
        let sortColumn = null;
        let sortDirection = 'asc';
        let selectedServices = new Set(); // Track selected service IDs
        let sentHistory = {
            version: 1,
            updated_at: null,
            entries: []
        };
        let sentEmailSet = new Set();
        let sentServiceIdSet = new Set();
        let scrapeRunInProgress = false;

        function normalizeEmail(value) {
            let email = (value || '').trim().toLowerCase();
            email = email.replace(/^<|>$/g, '');
            while (email && '.,;:'.includes(email[email.length - 1])) {
                email = email.slice(0, -1);
            }
            return email;
        }

        function isLikelyEmail(value) {
            const email = normalizeEmail(value);
            const regex = /^[A-Za-z0-9.!#$%&'*+/=?^_`{|}~-]+@(?:[A-Za-z0-9-]+\.)+[A-Za-z]{2,}$/;
            return regex.test(email) && !email.includes('..');
        }

        function rebuildSentIndexes() {
            sentEmailSet = new Set();
            sentServiceIdSet = new Set();

            sentHistory.entries.forEach(entry => {
                const email = normalizeEmail(entry.email || '');
                const serviceId = (entry.service_id || '').trim();
                if (email) sentEmailSet.add(email);
                if (serviceId) sentServiceIdSet.add(serviceId);
            });

            document.getElementById('sentCount').textContent = sentHistory.entries.length;
        }

        function dedupeHistoryEntries(entries) {
            const map = new Map();
            entries.forEach(entry => {
                const normalized = {
                    service_id: (entry.service_id || '').trim(),
                    email: normalizeEmail(entry.email || ''),
                    name: (entry.name || '').trim(),
                    sent_at: entry.sent_at || new Date().toISOString(),
                    source_file: entry.source_file || ''
                };
                if (!normalized.service_id && !normalized.email) {
                    return;
                }
                const key = normalized.service_id || normalized.email;
                if (!map.has(key)) {
                    map.set(key, normalized);
                }
            });
            return Array.from(map.values());
        }

        function normalizeHistoryEntries(entries, sourceLabel = '') {
            return entries
                .map(entry => ({
                    service_id: (entry.service_id || '').toString().trim(),
                    email: normalizeEmail((entry.email || '').toString()),
                    name: (entry.name || '').toString().trim(),
                    sent_at: entry.sent_at || new Date().toISOString(),
                    source_file: entry.source_file || sourceLabel
                }))
                .filter(entry => {
                    if (!entry.service_id && !entry.email) return false;
                    if (entry.email && !isLikelyEmail(entry.email)) return false;
                    return true;
                });
        }

        function saveSentHistoryToStorage() {
            sentHistory.updated_at = new Date().toISOString();
            localStorage.setItem(SENT_HISTORY_STORAGE_KEY, JSON.stringify(sentHistory));
        }

        function loadSentHistoryFromStorage() {
            const raw = localStorage.getItem(SENT_HISTORY_STORAGE_KEY);
            if (!raw) {
                rebuildSentIndexes();
                updateSentHistoryUI();
                return;
            }

            try {
                const parsed = JSON.parse(raw);
                const entries = Array.isArray(parsed?.entries) ? parsed.entries : [];
                sentHistory = {
                    version: 1,
                    updated_at: parsed?.updated_at || null,
                    entries: dedupeHistoryEntries(entries)
                };
            } catch (error) {
                sentHistory = { version: 1, updated_at: null, entries: [] };
            }

            rebuildSentIndexes();
            updateSentHistoryUI();
        }

        async function syncSentHistoryFromRepo(showAlert = false) {
            const historyUrl = `https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${GITHUB_BRANCH}/data/sent_emails_history.json?t=${Date.now()}`;

            try {
                const response = await fetch(historyUrl, { cache: 'no-store' });
                if (!response.ok) {
                    if (showAlert) {
                        alert('Nu am gƒÉsit fi»ôierul de istoric √Æn repo.');
                    }
                    return false;
                }

                const payload = await response.json();
                const extracted = extractHistoryEntries(payload);
                const normalized = normalizeHistoryEntries(extracted, 'repo-history');
                const beforeCount = sentHistory.entries.length;

                sentHistory.entries = dedupeHistoryEntries([...sentHistory.entries, ...normalized]);
                saveSentHistoryToStorage();
                rebuildSentIndexes();
                pruneSelectionForSent();
                updateSentHistoryUI();

                if (allServices.length > 0) {
                    applyFilters();
                } else {
                    updateStats();
                    updateSelectionUI();
                }

                if (showAlert) {
                    const added = sentHistory.entries.length - beforeCount;
                    alert(`Sincronizare finalizatƒÉ. IntrƒÉri adƒÉugate: ${added}. Total istoric: ${sentHistory.entries.length}.`);
                }
                return true;
            } catch (error) {
                if (showAlert) {
                    alert(`Nu am putut sincroniza istoricul din repo: ${error.message}`);
                }
                return false;
            }
        }

        async function manualSyncSentHistory() {
            await syncSentHistoryFromRepo(true);
        }

        function isServiceAlreadyContacted(service) {
            const email = normalizeEmail(service.email || '');
            const serviceId = (service.id || '').trim();
            if (serviceId && sentServiceIdSet.has(serviceId)) return true;
            if (email && sentEmailSet.has(email)) return true;
            return false;
        }

        function pruneSelectionForSent() {
            const keep = new Set();
            selectedServices.forEach(serviceId => {
                const service = allServices.find(s => s.id === serviceId);
                if (!service) return;
                if (!isServiceAlreadyContacted(service)) {
                    keep.add(serviceId);
                }
            });
            selectedServices = keep;
        }

        function updateSentHistoryUI() {
            const summary = document.getElementById('sentHistorySummary');
            const preview = document.getElementById('sentPreviewList');
            const total = sentHistory.entries.length;

            if (total === 0) {
                summary.textContent = 'Nu existƒÉ istoric √ÆncƒÉrcat.';
                preview.style.display = 'none';
                preview.innerHTML = '';
                return;
            }

            const updatedText = sentHistory.updated_at
                ? new Date(sentHistory.updated_at).toLocaleString('ro-RO')
                : '-';
            summary.textContent = `IntrƒÉri istorice: ${total}. Ultima actualizare: ${updatedText}.`;

            const previewEntries = sentHistory.entries.slice(-10).reverse();
            preview.innerHTML = previewEntries
                .map(entry => {
                    const label = entry.name || entry.email || entry.service_id;
                    const date = entry.sent_at ? new Date(entry.sent_at).toLocaleDateString('ro-RO') : '-';
                    return `<div>‚Ä¢ ${label} (${entry.email || 'fƒÉrƒÉ email'}) - ${date}</div>`;
                })
                .join('');
            preview.style.display = 'block';
        }

        function extractHistoryEntries(payload) {
            if (Array.isArray(payload)) {
                return payload;
            }

            if (Array.isArray(payload?.entries)) {
                return payload.entries;
            }

            if (Array.isArray(payload?.recipients)) {
                return payload.recipients.map(item => ({
                    service_id: item.service_id || '',
                    email: item.email || '',
                    name: item.name || '',
                    sent_at: payload?.created_at || new Date().toISOString(),
                    source_file: 'imported-recipients'
                }));
            }

            return [];
        }

        function triggerHistoryImport() {
            document.getElementById('historyFileInput').click();
        }

        async function handleHistoryFile(event) {
            const file = event.target.files?.[0];
            if (!file) return;

            try {
                const text = await file.text();
                const payload = JSON.parse(text);
                const extracted = extractHistoryEntries(payload);
                const normalized = normalizeHistoryEntries(extracted, file.name);

                sentHistory.entries = dedupeHistoryEntries([...sentHistory.entries, ...normalized]);
                saveSentHistoryToStorage();
                rebuildSentIndexes();
                pruneSelectionForSent();
                updateSentHistoryUI();
                updateSelectionUI();
                applyFilters();

                alert(`Istoric importat: ${normalized.length} intrƒÉri valide.`);
            } catch (error) {
                alert(`Nu am putut importa istoricul: ${error.message}`);
            } finally {
                event.target.value = '';
            }
        }

        function exportSentHistory() {
            const blob = new Blob([JSON.stringify(sentHistory, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `sent_emails_history_${new Date().toISOString().slice(0, 10)}.json`;
            link.click();
        }

        function clearSentHistory() {
            if (!confirm('»òtergi istoricul local de email-uri trimise?')) {
                return;
            }
            sentHistory = { version: 1, updated_at: null, entries: [] };
            localStorage.removeItem(SENT_HISTORY_STORAGE_KEY);
            rebuildSentIndexes();
            pruneSelectionForSent();
            updateSentHistoryUI();
            updateSelectionUI();
            applyFilters();
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getGithubTokenOrThrow() {
            const token = localStorage.getItem('github_token');
            if (!token) {
                throw new Error(
                    'GitHub token lipse»ôte.\n\nSeteazƒÉ √Æn browser console:\nlocalStorage.setItem("github_token", "YOUR_TOKEN")\n\nToken-ul trebuie sƒÉ aibƒÉ acces la Actions (workflow dispatch).'
                );
            }
            return token;
        }

        function setScrapeStatus(text, color = '#64748b') {
            const statusEl = document.getElementById('scrapeStatus');
            statusEl.textContent = text;
            statusEl.style.color = color;
        }

        async function getLatestScrapeRun(token) {
            const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/actions/workflows/${SCRAPE_WORKFLOW_FILE}/runs?branch=${GITHUB_BRANCH}&per_page=10`;
            const response = await fetch(url, {
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Accept': 'application/vnd.github+json'
                }
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.message || 'Nu am putut citi run-urile workflow-ului.');
            }

            const data = await response.json();
            return (data.workflow_runs || [])[0] || null;
        }

        async function dispatchScrapeWorkflow(token) {
            const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/actions/workflows/${SCRAPE_WORKFLOW_FILE}/dispatches`;
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Accept': 'application/vnd.github+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ ref: GITHUB_BRANCH })
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.message || 'Nu am putut porni workflow-ul de scraping.');
            }
        }

        async function waitForNewScrapeRun(token, previousRunId) {
            for (let i = 0; i < 30; i++) {
                const latest = await getLatestScrapeRun(token);
                if (latest && latest.id !== previousRunId) {
                    return latest;
                }
                await sleep(3000);
            }
            throw new Error('Workflow-ul a fost pornit, dar nu am gƒÉsit run-ul nou √Æn timp util.');
        }

        async function getRunById(token, runId) {
            const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/actions/runs/${runId}`;
            const response = await fetch(url, {
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Accept': 'application/vnd.github+json'
                }
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.message || 'Nu am putut citi statusul run-ului.');
            }
            return await response.json();
        }

        async function waitForRunCompletion(token, runId) {
            for (let i = 0; i < 120; i++) {
                const run = await getRunById(token, runId);
                const status = run.status || 'unknown';
                const conclusion = run.conclusion || '-';

                if (status === 'completed') {
                    return run;
                }

                setScrapeStatus(`CƒÉutare service-uri √Æn curs... (status: ${status}, conclusion: ${conclusion})`, '#0f766e');
                await sleep(10000);
            }
            throw new Error('Workflow-ul ruleazƒÉ prea mult; verificƒÉ manual √Æn tab-ul GitHub Actions.');
        }

        async function runScrapeWorkflow() {
            if (scrapeRunInProgress) {
                alert('ExistƒÉ deja o cƒÉutare √Æn curs.');
                return;
            }

            if (!confirm('Porne»ôti acum cƒÉutarea de service-uri noi (Google Places) din GitHub Actions?')) {
                return;
            }

            const button = document.getElementById('runScrapeBtn');
            scrapeRunInProgress = true;
            button.disabled = true;

            try {
                const token = getGithubTokenOrThrow();
                setScrapeStatus('Pornesc workflow-ul de cƒÉutare service-uri...', '#7c3aed');

                const previousRun = await getLatestScrapeRun(token);
                const previousRunId = previousRun ? previousRun.id : null;

                await dispatchScrapeWorkflow(token);
                setScrapeStatus('Workflow pornit. A»ôtept alocarea run-ului...', '#7c3aed');

                const newRun = await waitForNewScrapeRun(token, previousRunId);
                setScrapeStatus(`Run detectat (#${newRun.run_number}). Monitorizare √Æn curs...`, '#0f766e');

                const completedRun = await waitForRunCompletion(token, newRun.id);
                if (completedRun.conclusion !== 'success') {
                    throw new Error(`Workflow terminat cu '${completedRun.conclusion}'. VerificƒÉ run-ul: ${completedRun.html_url}`);
                }

                setScrapeStatus('Workflow finalizat cu succes. Re√Æncarc tabelul...', '#166534');
                const refreshed = await loadData();
                if (!refreshed) {
                    throw new Error('Scraping-ul a reu»ôit, dar nu am reu»ôit sƒÉ re√Æncarc datele √Æn tabel.');
                }

                setScrapeStatus(`CƒÉutare finalizatƒÉ cu succes. Ultimul run: #${completedRun.run_number}`, '#166534');
                alert(`CƒÉutare finalizatƒÉ »ôi tabel actualizat.\n\nRun: ${completedRun.html_url}`);
            } catch (error) {
                setScrapeStatus(`Eroare cƒÉutare service-uri: ${error.message}`, '#b91c1c');
                alert(`Nu am putut finaliza cƒÉutarea: ${error.message}`);
            } finally {
                scrapeRunInProgress = false;
                button.disabled = false;
            }
        }

        function setLoadingState(isLoading, message = '√éncƒÉrcare date...') {
            const loading = document.getElementById('loading');
            const errorDiv = document.getElementById('error');
            const table = document.getElementById('servicesTable');
            const pagination = document.getElementById('pagination');

            if (isLoading) {
                loading.textContent = message;
                loading.style.display = 'block';
                errorDiv.style.display = 'none';
                table.style.display = 'none';
                pagination.style.display = 'none';
            } else {
                loading.style.display = 'none';
                table.style.display = 'table';
                pagination.style.display = 'flex';
            }
        }

        // √éncƒÉrcare date
        async function loadData() {
            try {
                setLoadingState(true, 'Se actualizeazƒÉ lista service-urilor...');

                // URL cƒÉtre datele din GitHub (cache-busting pentru refresh imediat)
                const response = await fetch(`https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${GITHUB_BRANCH}/data/services.xml?t=${Date.now()}`);

                if (!response.ok) {
                    throw new Error('Nu s-au putut √ÆncƒÉrca datele');
                }

                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                const services = Array.from(xmlDoc.querySelectorAll('service')).map(s => ({
                    id: s.querySelector('id')?.textContent || '',
                    name: s.querySelector('name')?.textContent || '',
                    size: s.querySelector('size')?.textContent || 'unknown',
                    email: s.querySelector('email')?.textContent || '',
                    phone: s.querySelector('phone')?.textContent || '',
                    website: s.querySelector('website')?.textContent || '',
                    address: s.querySelector('address')?.textContent || '',
                    city: s.querySelector('city')?.textContent || '',
                    rating: parseFloat(s.querySelector('rating')?.textContent) || null,
                    reviews: parseInt(s.querySelector('reviews')?.textContent) || null,
                    source: s.querySelector('source')?.textContent || '',
                    last_updated: s.querySelector('last_updated')?.textContent || ''
                }));

                allServices = services;
                updateStats();
                populateCityFilter();
                applyFilters();

                setLoadingState(false);
                return true;
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                const errorDiv = document.getElementById('error');
                errorDiv.textContent = `Eroare: ${error.message}`;
                errorDiv.style.display = 'block';
                if (allServices.length > 0) {
                    document.getElementById('servicesTable').style.display = 'table';
                    document.getElementById('pagination').style.display = 'flex';
                }
                return false;
            }
        }

        async function rerunServiceSearch() {
            const ok = await loadData();
            if (ok) {
                alert('Lista de service-uri a fost actualizatƒÉ din sursa curentƒÉ.');
            }
        }

        async function refreshAllData() {
            loadSentHistoryFromStorage();
            await syncSentHistoryFromRepo(false);
            const ok = await loadData();
            updateSentHistoryUI();
            if (ok) {
                alert('Refresh complet finalizat: service-uri + istoric local re√ÆncƒÉrcate.');
            }
        }

        // Actualizare statistici
        function updateStats() {
            const emailCount = allServices.filter(s => s.email).length;
            const largeCount = allServices.filter(s => s.size === 'large').length;
            const lastUpdateTimestamp = allServices.reduce((maxTs, service) => {
                const raw = (service?.last_updated || '').trim();
                if (!raw) return maxTs;
                const ts = Date.parse(raw);
                if (Number.isNaN(ts)) return maxTs;
                return Math.max(maxTs, ts);
            }, 0);
            const sentCount = allServices.filter(s => isServiceAlreadyContacted(s)).length;
            const emailPct = allServices.length ? Math.round((emailCount * 100) / allServices.length) : 0;
            const lastUpdateDisplay = lastUpdateTimestamp
                ? new Date(lastUpdateTimestamp).toLocaleString('ro-RO', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                })
                : '-';

            document.getElementById('totalCount').textContent = allServices.length;
            document.getElementById('emailCount').textContent = `${emailCount} (${emailPct}%)`;
            document.getElementById('largeCount').textContent = largeCount;
            document.getElementById('lastUpdated').textContent = lastUpdateDisplay;
            document.getElementById('sentCount').textContent = sentCount;
        }

        // PopuleazƒÉ dropdown ora»ôul
        function populateCityFilter() {
            const select = document.getElementById('cityFilter');
            const previousValue = select.value;
            select.innerHTML = '<option value="">Toate Ora»ôele</option>';

            const cities = [...new Set(allServices.map(s => s.city))].filter(c => c).sort();

            cities.forEach(city => {
                const option = document.createElement('option');
                option.value = city;
                option.textContent = city;
                select.appendChild(option);
            });

            if (previousValue && cities.includes(previousValue)) {
                select.value = previousValue;
            }
        }

        // AplicƒÉ filtre
        function applyFilters() {
            pruneSelectionForSent();
            const cityFilter = document.getElementById('cityFilter').value;
            const searchFilter = document.getElementById('searchInput').value.toLowerCase();
            const emailOnly = document.getElementById('emailOnlyFilter').checked;
            const hideSent = document.getElementById('hideSentFilter').checked;
            const sizeFilters = Array.from(document.querySelectorAll('.checkbox-group input[type="checkbox"]:checked')).map(cb => cb.value);

            filteredServices = allServices.filter(s => {
                if (cityFilter && s.city !== cityFilter) return false;
                if (searchFilter && !s.name.toLowerCase().includes(searchFilter)) return false;
                if (emailOnly && !s.email) return false;
                if (hideSent && isServiceAlreadyContacted(s)) return false;
                if (sizeFilters.length && !sizeFilters.includes(s.size)) return false;
                return true;
            });

            currentPage = 1;
            updateStats();
            updateSelectionUI();
            renderTable();
        }

        // Sortare
        function sortBy(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }

            filteredServices.sort((a, b) => {
                let valA = a[column];
                let valB = b[column];

                if (valA === null || valA === '') return 1;
                if (valB === null || valB === '') return -1;

                if (typeof valA === 'string') {
                    valA = valA.toLowerCase();
                    valB = valB.toLowerCase();
                }

                if (sortDirection === 'asc') {
                    return valA > valB ? 1 : -1;
                } else {
                    return valA < valB ? 1 : -1;
                }
            });

            // Update headers
            document.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            const th = document.querySelector(`th[data-sort="${column}"]`);
            if (th) {
                th.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
            }

            renderTable();
        }

        // Render tabel
        function renderTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';

            const start = (currentPage - 1) * ITEMS_PER_PAGE;
            const end = start + ITEMS_PER_PAGE;
            const pageServices = filteredServices.slice(start, end);

            pageServices.forEach(service => {
                const row = document.createElement('tr');

                // Checkbox pentru selec»õie (doar dacƒÉ are email)
                const checkCell = document.createElement('td');
                const alreadySent = isServiceAlreadyContacted(service);
                if (service.email && !alreadySent) {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'service-checkbox';
                    checkbox.dataset.serviceId = service.id;
                    checkbox.dataset.email = service.email;
                    checkbox.dataset.name = service.name;
                    checkbox.checked = selectedServices.has(service.id);
                    checkbox.onchange = () => toggleServiceSelection(service.id, service.email, service.name, checkbox.checked);
                    checkCell.appendChild(checkbox);
                } else if (service.email && alreadySent) {
                    const sentBadge = document.createElement('span');
                    sentBadge.className = 'badge badge-sent';
                    sentBadge.textContent = 'trimis';
                    checkCell.appendChild(sentBadge);
                } else {
                    checkCell.textContent = '-';
                    checkCell.style.color = '#ccc';
                }

                // Nume cu link Google Maps
                const nameCell = document.createElement('td');
                const nameLink = document.createElement('a');
                nameLink.href = `https://www.google.com/maps/place/?q=place_id:${service.id}`;
                nameLink.target = '_blank';
                nameLink.textContent = service.name;
                nameCell.appendChild(nameLink);

                // Ora»ô
                const cityCell = document.createElement('td');
                cityCell.textContent = service.city;

                // Dimensiune cu badge
                const sizeCell = document.createElement('td');
                const sizeBadge = document.createElement('span');
                sizeBadge.className = `badge badge-${service.size}`;
                sizeBadge.textContent = service.size;
                sizeCell.appendChild(sizeBadge);

                // Rating
                const ratingCell = document.createElement('td');
                if (service.rating) {
                    ratingCell.innerHTML = `<span class="rating">‚≠ê ${service.rating.toFixed(1)}</span>`;
                } else {
                    ratingCell.textContent = '-';
                }

                // Reviews
                const reviewsCell = document.createElement('td');
                reviewsCell.textContent = service.reviews || '-';

                // Email
                const emailCell = document.createElement('td');
                if (service.email) {
                    const emailDiv = document.createElement('div');
                    emailDiv.className = 'email-cell';
                    const emailLink = document.createElement('a');
                    emailLink.href = `mailto:${service.email}`;
                    emailLink.textContent = service.email;
                    const copyBtn = document.createElement('span');
                    copyBtn.className = 'copy-btn';
                    copyBtn.textContent = 'üìã';
                    copyBtn.title = 'CopiazƒÉ';
                    copyBtn.onclick = () => {
                        navigator.clipboard.writeText(service.email);
                        copyBtn.textContent = '‚úì';
                        setTimeout(() => copyBtn.textContent = 'üìã', 1000);
                    };
                    emailDiv.appendChild(emailLink);
                    emailDiv.appendChild(copyBtn);
                    if (alreadySent) {
                        const sentTag = document.createElement('span');
                        sentTag.className = 'badge badge-sent';
                        sentTag.textContent = 'deja contactat';
                        emailDiv.appendChild(sentTag);
                    }
                    emailCell.appendChild(emailDiv);
                } else {
                    emailCell.textContent = '-';
                }

                // Telefon
                const phoneCell = document.createElement('td');
                if (service.phone) {
                    const phoneLink = document.createElement('a');
                    phoneLink.href = `tel:${service.phone}`;
                    phoneLink.textContent = service.phone;
                    phoneCell.appendChild(phoneLink);
                } else {
                    phoneCell.textContent = '-';
                }

                // Website
                const websiteCell = document.createElement('td');
                if (service.website) {
                    const websiteLink = document.createElement('a');
                    websiteLink.href = service.website;
                    websiteLink.target = '_blank';
                    websiteLink.innerHTML = 'üåê';
                    websiteCell.appendChild(websiteLink);
                } else {
                    websiteCell.textContent = '-';
                }

                row.appendChild(checkCell);
                row.appendChild(nameCell);
                row.appendChild(cityCell);
                row.appendChild(sizeCell);
                row.appendChild(ratingCell);
                row.appendChild(reviewsCell);
                row.appendChild(emailCell);
                row.appendChild(phoneCell);
                row.appendChild(websiteCell);

                tbody.appendChild(row);
            });

            updatePagination();
        }

        // Paginare
        function updatePagination() {
            const totalPages = Math.ceil(filteredServices.length / ITEMS_PER_PAGE);
            document.getElementById('pageInfo').textContent = `Pagina ${currentPage} din ${totalPages} (${filteredServices.length} rezultate)`;

            const buttons = document.querySelectorAll('.pagination button');
            buttons[0].disabled = currentPage === 1;
            buttons[1].disabled = currentPage === totalPages || totalPages === 0;
        }

        function nextPage() {
            const totalPages = Math.ceil(filteredServices.length / ITEMS_PER_PAGE);
            if (currentPage < totalPages) {
                currentPage++;
                renderTable();
                window.scrollTo(0, 0);
            }
        }

        function prevPage() {
            if (currentPage > 1) {
                currentPage--;
                renderTable();
                window.scrollTo(0, 0);
            }
        }

        // Clear filters
        function clearFilters() {
            document.getElementById('cityFilter').value = '';
            document.getElementById('searchInput').value = '';
            document.getElementById('emailOnlyFilter').checked = false;
            document.getElementById('hideSentFilter').checked = false;
            document.querySelectorAll('.checkbox-group input[type="checkbox"]').forEach(cb => cb.checked = true);
            applyFilters();
        }

        // Export CSV
        function exportFilteredCSV() {
            const headers = ['Nume', 'Ora»ô', 'Dimensiune', 'Email', 'Telefon', 'Website', 'AdresƒÉ', 'Rating', 'Review-uri'];
            const rows = filteredServices.map(s => [
                s.name,
                s.city,
                s.size,
                s.email,
                s.phone,
                s.website,
                s.address,
                s.rating || '',
                s.reviews || ''
            ]);

            const csvContent = [
                headers.join(','),
                ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `service-uri-auto-${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
        }

        // ========================================
        // EMAIL FUNCTIONALITY
        // ========================================

        function setLocalSendStatus(text, color = '#64748b') {
            const statusEl = document.getElementById('localSendStatus');
            if (!statusEl) return;
            statusEl.textContent = text;
            statusEl.style.color = color;
        }

        function buildEligibleRecipientsFromSelection() {
            const recipients = [];
            selectedServices.forEach(serviceId => {
                const service = allServices.find(s => s.id === serviceId);
                if (!service || !service.email) return;
                if (isServiceAlreadyContacted(service)) return;
                recipients.push({
                    service_id: service.id,
                    email: normalizeEmail(service.email),
                    name: service.name
                });
            });
            return recipients;
        }

        async function pushSentHistoryToRepo() {
            const token = localStorage.getItem('github_token');
            if (!token) {
                return { ok: false, skipped: true, reason: 'missing_token' };
            }

            const path = 'data/sent_emails_history.json';
            let sha = null;

            try {
                const getResponse = await fetch(`https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${path}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (getResponse.ok) {
                    const data = await getResponse.json();
                    sha = data.sha;
                }
            } catch (error) {
                // ignore: create file on PUT
            }

            const content = btoa(unescape(encodeURIComponent(JSON.stringify(sentHistory, null, 2))));
            const payload = {
                message: `Update sent email history (${new Date().toISOString()})`,
                content,
                branch: GITHUB_BRANCH,
                sha
            };

            const updateResponse = await fetch(`https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${path}`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (!updateResponse.ok) {
                const err = await updateResponse.json().catch(() => ({}));
                return { ok: false, skipped: false, reason: err.message || 'push_failed' };
            }

            return { ok: true, skipped: false };
        }

        async function sendEmailsDirectLocal() {
            const count = selectedServices.size;
            if (count === 0) {
                alert('Te rog selecteazƒÉ cel pu»õin un service din tabel.');
                return;
            }

            const recipients = buildEligibleRecipientsFromSelection();
            if (recipients.length === 0) {
                alert('Nu mai existƒÉ adrese eligibile (toate sunt deja contactate sau invalide).');
                clearSelection();
                return;
            }

            const confirmMessage = `Vei trimite DIRECT din Apple Mail cƒÉtre ${recipients.length} service-uri eligibile.\n\nContinuƒÉm?`;
            if (!confirm(confirmMessage)) {
                return;
            }

            const sendBtn = document.getElementById('sendDirectBtn');
            sendBtn.disabled = true;
            setLocalSendStatus('Verific local bridge...', '#0ea5e9');

            try {
                const healthResponse = await fetch(`${LOCAL_MAIL_BRIDGE_URL}/health`);
                if (!healthResponse.ok) {
                    throw new Error('Local bridge indisponibil.');
                }

                const payload = {
                    recipients,
                    delay: 1.0,
                    dry_run: false,
                    force_resend: false
                };

                setLocalSendStatus('Se trimit email-urile prin Apple Mail...', '#0f766e');
                const sendResponse = await fetch(`${LOCAL_MAIL_BRIDGE_URL}/send-selected`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const sendData = await sendResponse.json().catch(() => ({}));
                if (!sendResponse.ok) {
                    throw new Error(sendData.error || `HTTP ${sendResponse.status}`);
                }

                const sentEntries = Array.isArray(sendData.sent_entries) ? sendData.sent_entries : [];
                if (sentEntries.length > 0) {
                    const normalized = normalizeHistoryEntries(sentEntries, 'local-mail-bridge');
                    sentHistory.entries = dedupeHistoryEntries([...sentHistory.entries, ...normalized]);
                    saveSentHistoryToStorage();
                    rebuildSentIndexes();
                    pruneSelectionForSent();
                    updateSentHistoryUI();
                    updateSelectionUI();
                    applyFilters();
                }

                const pushResult = await pushSentHistoryToRepo();
                if (pushResult.ok) {
                    setLocalSendStatus(`Trimise: ${sendData.summary?.sent || 0}. Istoric sincronizat »ôi √Æn repo.`, '#166534');
                } else if (pushResult.skipped) {
                    setLocalSendStatus(`Trimise: ${sendData.summary?.sent || 0}. Istoric actualizat local (token GitHub lipsƒÉ).`, '#166534');
                } else {
                    setLocalSendStatus(`Trimise: ${sendData.summary?.sent || 0}. Repo sync e»ôuat: ${pushResult.reason}`, '#b45309');
                }

                clearSelection();
                await loadData();

                alert(
                    `Trimitere finalizatƒÉ.\n\n` +
                    `Trimise: ${sendData.summary?.sent || 0}\n` +
                    `E»ôuate: ${sendData.summary?.failed || 0}\n` +
                    `Skip: ${sendData.summary?.skipped || 0}\n` +
                    `Raport: ${sendData.report_path || '-'}`
                );
            } catch (error) {
                setLocalSendStatus(`Eroare trimitere localƒÉ: ${error.message}`, '#b91c1c');
                alert(
                    `Nu am putut trimite direct din webapp.\n\n` +
                    `1. RuleazƒÉ √Æn Terminal: python3 local_mail_bridge.py\n` +
                    `2. LasƒÉ-l deschis\n` +
                    `3. Re√ÆncearcƒÉ butonul\n\n` +
                    `Detalii: ${error.message}`
                );
            } finally {
                sendBtn.disabled = selectedServices.size === 0;
            }
        }

        function toggleServiceSelection(serviceId, email, name, isChecked) {
            if (isChecked) {
                selectedServices.add(serviceId);
            } else {
                selectedServices.delete(serviceId);
            }
            updateSelectionUI();
        }

        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAll');
            const checkboxes = document.querySelectorAll('.service-checkbox');

            checkboxes.forEach(cb => {
                cb.checked = selectAllCheckbox.checked;
                const serviceId = cb.dataset.serviceId;
                if (selectAllCheckbox.checked) {
                    selectedServices.add(serviceId);
                } else {
                    selectedServices.delete(serviceId);
                }
            });

            updateSelectionUI();
        }

        function clearSelection() {
            selectedServices.clear();
            document.getElementById('selectAll').checked = false;
            document.querySelectorAll('.service-checkbox').forEach(cb => cb.checked = false);
            updateSelectionUI();
        }

        function updateSelectionUI() {
            const count = selectedServices.size;
            document.getElementById('selectedCount').textContent = `${count} selectate`;
            document.getElementById('sendEmailBtn').disabled = count === 0;
            document.getElementById('sendDirectBtn').disabled = count === 0;

            // Show/hide email actions panel
            const emailActions = document.getElementById('emailActions');
            if (count > 0) {
                emailActions.style.display = 'block';
            } else {
                emailActions.style.display = 'none';
            }
        }

        async function sendTestEmail() {
            if (!confirm('Trimite email de test cƒÉtre ionescuionut18@gmail.com?')) {
                return;
            }

            const queue = {
                recipients: [{
                    service_id: 'test-email',
                    email: 'ionescuionut18@gmail.com',
                    name: 'Test Service Auto'
                }],
                is_test: true,
                created_at: new Date().toISOString()
            };

            try {
                await commitEmailQueue(queue);
                alert('‚úÖ Email de test programat!\n\nVa fi trimis √Æn 2-3 minute.\nVerificƒÉ inbox-ul la ionescuionut18@gmail.com');
            } catch (error) {
                alert('‚ùå Eroare: ' + error.message);
            }
        }

        async function sendEmailsToSelected() {
            const count = selectedServices.size;

            if (count === 0) {
                alert('Te rog selecteazƒÉ cel pu»õin un service din tabel.');
                return;
            }

            const message = `Vei descƒÉrca lista cu ${count} service-uri.\n\nApoi ruleazƒÉ script-ul local pentru a trimite email-urile.\n\nContinui?`;

            if (!confirm(message)) {
                return;
            }

            const recipients = buildEligibleRecipientsFromSelection();

            if (recipients.length === 0) {
                alert('Nu mai existƒÉ adrese eligibile (toate sunt deja contactate sau invalide).');
                clearSelection();
                return;
            }

            const emailData = {
                recipients: recipients,
                campaign_name: "Auto Service RCA Collaboration",
                created_at: new Date().toISOString(),
                total_count: recipients.length
            };

            try {
                // Download JSON file
                downloadEmailList(emailData);

                alert(`‚úÖ Lista de email-uri descƒÉrcatƒÉ!\n\nüìÅ Fi»ôier: email_recipients.json\nüìä Total: ${recipients.length} service-uri eligibile\n\nüìù Next steps:\n1. Deschide Terminal\n2. cd /Users/ionut/Desktop/App-scraping-service-auto\n3. python3 trimite_emailuri_apple_mail.py --input ~/Downloads/email_recipients.json\n4. DupƒÉ trimitere, importƒÉ data/sent_emails_history.json √Æn sec»õiunea "Istoric Email-uri Trimise".`);

                // Clear selection dupƒÉ download
                clearSelection();

            } catch (error) {
                alert('‚ùå Eroare la descƒÉrcarea listei:\n\n' + error.message);
            }
        }

        function downloadEmailList(data) {
            // Create JSON blob
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });

            // Create download link
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'email_recipients.json';
            link.click();
        }

        async function commitEmailQueue(queue) {
            // AceastƒÉ func»õie va salva queue-ul √Æn data/email_queue.json
            // »ôi va face commit + push pe GitHub

            const token = localStorage.getItem('github_token');
            if (!token) {
                throw new Error('GitHub token lipse»ôte!\n\nTrebuie sƒÉ configurezi un Personal Access Token √Æn browser console:\nlocalStorage.setItem("github_token", "YOUR_TOKEN")');
            }

            const path = 'data/email_queue.json';

            // Get current file SHA (pentru update)
            let sha = null;
            try {
                const getResponse = await fetch(`https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${path}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (getResponse.ok) {
                    const data = await getResponse.json();
                    sha = data.sha;
                }
            } catch (e) {
                // File doesn't exist yet, that's OK
            }

            // Create/update file
            const content = btoa(unescape(encodeURIComponent(JSON.stringify(queue, null, 2))));

            const updateResponse = await fetch(`https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${path}`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: `Add email queue - ${queue.recipients.length} recipients`,
                    content: content,
                    branch: GITHUB_BRANCH,
                    sha: sha
                })
            });

            if (!updateResponse.ok) {
                const error = await updateResponse.json();
                throw new Error(error.message || 'Failed to commit email queue');
            }

            return await updateResponse.json();
        }

        // ========================================
        // END EMAIL FUNCTIONALITY
        // ========================================

        // Event listeners
        document.getElementById('cityFilter').addEventListener('change', applyFilters);
        document.getElementById('searchInput').addEventListener('input', debounce(applyFilters, 300));
        document.getElementById('emailOnlyFilter').addEventListener('change', applyFilters);
        document.getElementById('hideSentFilter').addEventListener('change', applyFilters);
        document.querySelectorAll('.checkbox-group input[type="checkbox"]').forEach(cb => {
            cb.addEventListener('change', applyFilters);
        });

        document.querySelectorAll('th.sortable').forEach(th => {
            th.addEventListener('click', () => sortBy(th.dataset.sort));
        });

        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // √éncarcƒÉ istoricul local + din repo, apoi datele din GitHub
        async function initializeDashboard() {
            loadSentHistoryFromStorage();
            await syncSentHistoryFromRepo(false);
            await loadData();
        }

        initializeDashboard();
    </script>
</body>
</html>
